/*
 * Copyright 2023 Aiven Oy
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

subprojects { subproject ->
    tasks.register("validateDeps") {
        doLast {
            def depVersions = [:]

            subproject.configurations.findAll {
                it.name == 'runtimeClasspath'
            }.forEach { config ->
                if (config.canBeResolved) {
                    try {
                        config.resolvedConfiguration.lenientConfiguration.allModuleDependencies.each { dep ->
                            dep.moduleArtifacts.each { artifact ->
                                def groupId = artifact.moduleVersion.id.group
                                def artifactId = artifact.moduleVersion.id.name
                                def version = artifact.moduleVersion.id.version
                                def key = "${groupId}:${artifactId}".toString()

                                depVersions[key] = version
                            }

                        }
                    } catch (Exception e) {
                        println "Couldn't resolve configuration ${config.name}: ${e.message}"
                    }
                }
            }

            // Validate transient dependencies between storage modules and core deps
            def coreDeps = [project(":core"), project(":commons")]
            def conflictsFound = false

            coreDeps.forEach { prj ->
                def configs = prj.configurations.findAll {
                    it.name == 'runtimeClasspath'
                }
                configs.each { config ->
                    if (config.canBeResolved) {
                        try {
                            config.resolvedConfiguration.lenientConfiguration.allModuleDependencies.each { dep ->
                                dep.moduleArtifacts.each { artifact ->
                                    def groupId = artifact.moduleVersion.id.group
                                    def artifactId = artifact.moduleVersion.id.name
                                    def version = artifact.moduleVersion.id.version
                                    def key = "${groupId}:${artifactId}".toString()

                                    if (depVersions.containsKey(key)) {
                                        if (depVersions[key] != version) {
                                            println "Conflict found on ${subproject.name} for ${key}: ${depVersions[key]} vs ${version}"
                                            conflictsFound = true
                                        }
                                    } else {
                                        depVersions[key] = version
                                    }
                                }

                            }
                        } catch (Exception e) {
                            println "Couldn't resolve configuration ${config.name}: ${e.message}"
                        }
                    }
                }
            }

            assert !conflictsFound: "Dependency conflicts found!"
        }
    }

    tasks.named("check") {
        dependsOn(tasks.named("validateDeps"))
    }
}
